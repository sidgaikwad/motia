---
title: Triggers
description: Understanding how Steps are triggered - API, Event, and Cron
---

Every Trigger has a `Step type` that defines **how it triggers**. The same handler pattern works across all trigger types, only the trigger mechanism changes.

<Tabs items={['API', 'Event', 'Cron']}>
<Tab value='API'>

## API Trigger

An **API Trigger** exposes an HTTP endpoint that acts as an entry point into your flows. It allows external systems or clients to trigger and interact with your workflows through a REST API interface.

### Configuration

The following properties are specific to API Steps:

<DescriptionTable
  type={{
    path: {
      description: 'The HTTP path for the API endpoint',
      type: 'string',
    },
    method: {
      description: 'The HTTP method for the API endpoint (GET, POST, PUT, DELETE, etc.)',
      type: 'string',
    },
    bodySchema: {
      description:
        'Schema for validating the request body. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models.',
      type: 'object',
    },
    responseSchema: {
      description:
        'Mostly used for documentation, the expected output of an API endpoint. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models or Dict Json Schema.',
      type: 'object',
    },
    queryParams: {
      description: 'Mostly for documentation, the expected query params',
      type: 'array',
    },
    middleware: {
      description: 'Optional middleware functions to run before the handler',
      type: 'array',
    },
  }}
/>

### Basic Example

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiRouteConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'GetMessage',
      description: 'Retrieves a generated message from OpenAI based on the Trace ID',
      path: '/openai/:traceId',
      method: 'GET',
      emits: ['call-openai'],
      flows: ['openai'],
      responseSchema: {
        200: z.object({ message: z.string({ description: 'The message from OpenAI' }) }),
        400: z.object({ message: z.string({ description: 'The error message' }) })
      },
      queryParams: [
        {
          name: 'includeProps',
          description: 'Whether to include the properties of the message',
        },
      ],
    }

    export const handler: Handlers['GetMessage'] = async (req, { logger }) => {
      logger.info('[Call OpenAI] Received callOpenAi event', req)

      return {
        status: 200,
        body: { message: 'OpenAI response sent' },
      }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const { z } = require('zod')

    export const config = {
      type: 'api',
      name: 'GetMessage',
      description: 'Retrieves a generated message from OpenAI',
      path: '/openai/:traceId',
      method: 'GET',
      emits: ['call-openai'],
      flows: ['openai'],
      responseSchema: {
        200: z.object({ message: z.string({ description: 'The message from OpenAI' }) }),
        400: z.object({ message: z.string({ description: 'The error message' }) })
      },
      queryParams: [
        {
          name: 'includeProps',
          description: 'Whether to include the properties of the message',
        },
      ],
    }

    export const handler = async (req, { logger }) => {
      logger.info('[Call OpenAI] Received callOpenAi event', req)

      return {
        status: 200,
        body: { message: 'OpenAI response sent' },
      }
    }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    from pydantic import BaseModel
    
    class RequestBody(BaseModel):
        message: str

    config = {
      "type": "api",
      "name": "GetMessage",
      "description": "Retrieves a generated message from OpenAI",
      "path": "/openai/:traceId",
      "method": "GET",
      "emits": ["call-openai"],
      "flows": ["openai"],
      "responseSchema": {
        "200": RequestBody.model_json_schema()
      },
      "queryParams": [
        {
          "name": "includeProps",
          "description": "Whether to include the properties of the message",
        },
      ],
    }

    async def handler(req, context):
      context.logger.info("[Call OpenAI] Received callOpenAi event", {"body": req.get("body")})

      return {
        "status": 200,
        "body": { "message": "OpenAI response sent" },
      }
    ```
  </Tab>
</Tabs>

### Using Middleware

API Steps support middleware functions that run before the handler. Middleware can perform tasks such as:

- Authentication and authorization
- Request logging
- Rate limiting
- CORS handling
- Request validation
- Response transformation

#### Middleware Function Signature

```typescript
type ApiMiddleware = (req: ApiRequest, ctx: FlowContext, next: () => Promise<ApiResponse>) => Promise<ApiResponse>
```

Middleware functions receive:
- `req`: The API request object with body, headers, pathParams, and queryParams
- `ctx`: The flow context with logger, state, emit, and traceId
- `next`: A function to call the next middleware or handler in the chain

#### Example Middleware

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { ApiMiddleware, ApiRouteConfig, Handlers } from 'motia'

    // Authentication middleware
    const authMiddleware: ApiMiddleware = async (req, ctx, next) => {
      const authHeader = req.headers.authorization

      if (!authHeader) {
        return {
          status: 401,
          body: { error: 'Unauthorized' },
        }
      }

      return next()
    }

    // Logging middleware
    const loggingMiddleware: ApiMiddleware = async (req, ctx, next) => {
      ctx.logger.info('Request received', { path: req.pathParams })
      const start = Date.now()

      const response = await next()

      const duration = Date.now() - start
      ctx.logger.info('Request completed', { duration, status: response.status })

      return response
    }

    export const config: ApiRouteConfig = {
      type: 'api',
      name: 'ProtectedEndpoint',
      path: '/api/protected',
      method: 'POST',
      emits: ['USER_ACTION'],
      middleware: [loggingMiddleware, authMiddleware],
    }

    export const handler: Handlers['ProtectedEndpoint'] = async (req, ctx) => {
      return {
        status: 200,
        body: { message: 'Protected data accessed successfully' },
      }
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    // Authentication middleware
    const authMiddleware = async (req, ctx, next) => {
      const authHeader = req.headers.authorization

      if (!authHeader) {
        return {
          status: 401,
          body: { error: 'Unauthorized' },
        }
      }

      return next()
    }

    // Logging middleware
    const loggingMiddleware = async (req, ctx, next) => {
      ctx.logger.info('Request received', { path: req.pathParams })
      const start = Date.now()

      const response = await next()

      const duration = Date.now() - start
      ctx.logger.info('Request completed', { duration, status: response.status })

      return response
    }

    exports.config = {
      type: 'api',
      name: 'ProtectedEndpoint',
      path: '/api/protected',
      method: 'POST',
      emits: ['USER_ACTION'],
      middleware: [loggingMiddleware, authMiddleware],
    }

    exports.handler = async (req, ctx) => {
      return {
        status: 200,
        body: { message: 'Protected data accessed successfully' },
      }
    }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    from typing import Any, Dict, Callable

    # Authentication middleware
    async def auth_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
        auth_header = data['headers'].get('authorization')

        if not auth_header:
            return {
                'status': 401,
                'body': {'error': 'Unauthorized'}
            }

        return await next_fn()

    # Logging middleware
    async def logging_middleware(data: Dict[str, Any], ctx: Any, next_fn: Callable):
        import time
        ctx.logger.info('Request received', {'path': data.get('pathParams')})
        start = time.time()

        response = await next_fn()

        duration = time.time() - start
        ctx.logger.info('Request completed', {'duration': duration, 'status': response.get('status')})

        return response

    config = {
        'type': 'api',
        'name': 'ProtectedEndpoint',
        'path': '/api/protected',
        'method': 'POST',
        'emits': ['USER_ACTION'],
        'middleware': [logging_middleware, auth_middleware]
    }

    async def handler(req, context):
        return {
            'status': 200,
            'body': {'message': 'Protected data accessed successfully'}
        }
    ```
  </Tab>
</Tabs>

</Tab>

<Tab value='Event'>

## Event Trigger

The **Event Trigger** lets you define custom logic in response to subscribed events and trigger other Steps by emitting new events. This enables event-driven communication between different parts of your flow.

### Configuration

The following properties are specific to Event Steps:

<DescriptionTable
  type={{
    subscribes: {
      description: 'Array of event topics this step listens to',
      type: 'string[]',
    },
    input: {
      description:
        'Schema for input validation. For TypeScript/JavaScript steps, it uses zod schemas. For Python steps, it uses Pydantic models.',
      type: 'object',
    },
  }}
/>

### Basic Example

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { EventConfig, Handlers } from 'motia'
    import { z } from 'zod'

    export const config: EventConfig = {
      type: 'event',
      name: 'ProcessMessage',
      description: 'Processes incoming messages',
      subscribes: ['message.sent'],
      emits: ['message.processed'],
      input: z.object({ message: z.string() }),
      flows: ['messaging'],
    }

    export const handler: Handlers['ProcessMessage'] = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)

      await emit({
        topic: 'message.processed',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const z = require('zod')

    const config = {
      type: 'event',
      name: 'ProcessMessage',
      description: 'Processes incoming messages',
      subscribes: ['message.sent'],
      emits: ['message.processed'],
      input: z.object({ message: z.string() }),
      flows: ['messaging'],
    }

    const handler = async (input, { emit, logger }) => {
      logger.info('Processing message:', input.message)

      await emit({
        topic: 'message.processed',
        data: {
          result: `Processed: ${input.message}`
        }
      })
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    config = {
      "type": "event",
      "name": "ProcessMessage",
      "description": "Processes incoming messages",
      "subscribes": ["message.sent"], 
      "emits": ["message.processed"],
      "input": {
        "type": "object",
        "properties": { "message": {"type": "string"} },
      },
      "flows": ["messaging"]
    }

    async def handler(input, context):
      context.logger.info("Processing message:", { "input": input })

      await context.emit({
        "topic": "message.processed",
        "data": {
          "result": f"Processed: {input.get('message', '')}"
        }
      })
    ```
  </Tab>
</Tabs>

### Event Flow Example

Event Steps are ideal for building event-driven workflows:

```
API Step          Event Step         Event Step
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST     â”‚ --> â”‚ Validate     â”‚-->â”‚ Send Email   â”‚
â”‚ /signup  â”‚     â”‚ User         â”‚   â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  emits:           subscribes:        subscribes:
  'user.created'   'user.created'     'user.validated'
                   emits:
                   'user.validated'
```

</Tab>

<Tab value='Cron'>

## Cron Trigger

The **Cron Trigger** allows you to schedule your Steps to run at specified intervals using cron expressions.

### Configuration

The following properties are specific to Cron Steps:

<DescriptionTable
  type={{
    cron: {
      description: 'The cron schedule expression for your step',
      type: 'string',
    },
  }}
/>

### Basic Example

<Tabs items={['TypeScript', 'JavaScript', 'Python']}>
  <Tab value="TypeScript">
    ```typescript
    import { CronConfig, Handlers } from 'motia'

    export const config: CronConfig = {
      type: 'cron' as const,
      name: 'PeriodicJob',
      description: 'Runs every hour and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    }

    export const handler: Handlers['PeriodicJob'] = async ({ emit, logger }) => {
      logger.info('Cron job executing')
      
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed', timestamp: new Date() },
      })
    }
    ```
  </Tab>
  <Tab value="JavaScript">
    ```javascript
    const config = {
      type: 'cron',
      name: 'PeriodicJob',
      description: 'Runs every hour and emits a timestamp',
      cron: '0 * * * *', // run every hour at minute 0
      emits: ['cron-ticked'],
      flows: ['cron-example'],
    }

    const handler = async ({ emit, logger }) => {
      logger.info('Cron job executing')
      
      await emit({
        topic: 'cron-ticked',
        data: { message: 'Cron job executed', timestamp: new Date() },
      })
    }

    module.exports = { config, handler }
    ```
  </Tab>
  <Tab value="Python">
    ```python
    from datetime import datetime

    config = {
        "type": "cron",
        "name": "PeriodicJob",
        "description": "Runs every hour and emits a timestamp",
        "cron": "0 * * * *",
        "emits": ["cron-ticked"],
        "flows": ["cron-example"]
    }
  
    async def handler(context):
        context.logger.info('Cron job executing')
        
        await context.emit({
            "topic": "cron-ticked",
            "data": { 
                "message": "Cron job executed",
                "timestamp": datetime.now().isoformat()
            },
        })
    ```
  </Tab>
</Tabs>

### Cron Expression Examples

| Expression | Description |
|------------|-------------|
| `* * * * *` | Every minute |
| `0 * * * *` | Every hour at minute 0 |
| `0 0 * * *` | Every day at midnight |
| `0 9 * * 1` | Every Monday at 9 AM |
| `0 0 1 * *` | First day of every month at midnight |
| `*/15 * * * *` | Every 15 minutes |

### Use Cases

Cron Steps are perfect for:
- Daily/weekly reports
- Data cleanup tasks
- Periodic sync operations
- Scheduled notifications
- Batch processing jobs
- Health checks and monitoring

</Tab>
</Tabs>

## Choosing the Right Trigger

| Trigger | When to Use | Example |
|---------|-------------|---------|
| **API** | External requests, webhooks, user actions | REST endpoints, webhook receivers |
| **Event** | Background processing, async workflows | Email sending, data processing, notifications |
| **Cron** | Scheduled tasks, periodic jobs | Daily reports, cleanup tasks, sync operations |

## Common Patterns

### API â†’ Event Chain

API receives request, emits event for async processing:

```typescript
// API Step
export const config = {
  type: 'api',
  path: '/orders',
  method: 'POST',
  emits: ['order.created']
}

// Event Step (async processing)
export const config = {
  type: 'event',
  subscribes: ['order.created'],
  emits: ['order.processed']
}
```

### Cron â†’ Event Chain

Scheduled task triggers event-driven workflow:

```typescript
// Cron Step
export const config = {
  type: 'cron',
  cron: '0 0 * * *', // Daily at midnight
  emits: ['daily.report.requested']
}

// Event Step
export const config = {
  type: 'event',
  subscribes: ['daily.report.requested'],
  emits: ['daily.report.generated']
}
```

## What's Next?

<Cards>
  <Card href="/docs/concepts/steps/defining-steps" title="ðŸ“ Defining Steps">
    Learn the fundamentals of creating Steps
  </Card>
  
  <Card href="/docs/development-guide/state-management" title="ðŸ”„ State Management">
    Share data between Steps
  </Card>
</Cards>
